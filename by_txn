-- CREATE VIEWS

--CREATE VIEW gtfs_test.v_most_current_routes_per_feed AS (
--	WITH gtfs_data AS (
--		SELECT DISTINCT
--			f.feed_id
--			, r.route_id
--			, r.route_short_name
--			, r.route_long_name
--			, f.agency_id AS trac_agency_id
--			, min(c.start_date) start_date
--			, max(c.end_date) end_date
--			, ROW_NUMBER() OVER (
--				PARTITION BY
--					f.agency_id
--			 		, r.route_id
--			 		, min(c.start_date)
--			 		, max(c.end_date)
--			 	ORDER BY f.feed_id DESC
--			) AS route_rank
--	    FROM _test.real_transitland_routes AS r 
--	    JOIN _test.real_gtfs_feeds AS f
--	    	ON r.feed_id = f.feed_id
--	    JOIN _test.real_transitland_trips AS t
--	    	ON t.feed_id = r.feed_id
--	    	AND t.route_id = r.route_id
--	    JOIN _test.real_transitland_calendar AS c
--	    	ON c.feed_id = t.feed_id
--	    	AND c.service_id = t.service_id
--	    GROUP BY 
--	    	r.route_id
--	    	, f.feed_id 
--	    	, f.agency_id
--	    	, r.route_short_name
--	    	, r.route_long_name 
--	)
--	SELECT 
--		feed_id
--		, route_id
--		, route_short_name
--		, route_long_name
--		, trac_agency_id
--		, start_date
--		, end_date
--		, route_rank
--	FROM gtfs_data
--	WHERE route_rank = 1
--);
--
--SELECT * FROM gtfs_test.v_most_current_routes_per_feed 



--CREATE VIEW gtfs_test.v_gtfs_trip_directions AS (
--	SELECT DISTINCT 
--		r.feed_id
--		, r.route_id
--		, r.trac_agency_id
--		, t.shape_id
--		, t.trip_id
--		, t.service_id
--		, t.direction_id
--		, FIRST_VALUE(st.arrival_time) OVER (
--			PARTITION BY 
--				r.feed_id
--				, r.route_id
--				, r.trac_agency_id
--				, t.shape_id
--				, t.trip_id
--			ORDER BY st.stop_sequence ) AS first_stop_time
--		, LAST_VALUE(st.departure_time) OVER (
--			PARTITION BY 
--				r.feed_id
--				, r.route_id
--				, r.trac_agency_id
--				, t.shape_id
--				, t.trip_id
--			ORDER BY st.stop_sequence ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_stop_time
--		, ARRAY_AGG(st.stop_id) OVER (
--			PARTITION BY 
--				r.feed_id
--				, r.route_id
--				, r.trac_agency_id
--				, t.shape_id
--				, t.trip_id
--			ORDER BY st.stop_sequence ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS stops_arr
--		, array[
--			CASE
--				WHEN (
--					LAST_VALUE(s.stop_lat::numeric) OVER (
--						PARTITION BY 
--							r.feed_id
--							, r.route_id
--							, r.trac_agency_id
--							, t.shape_id
--							, t.trip_id
--						ORDER BY st.stop_sequence ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
--					- FIRST_VALUE(s.stop_lat::numeric) OVER (
--						PARTITION BY 
--							r.feed_id
--							, r.route_id
--							, r.trac_agency_id
--							, t.shape_id
--							, t.trip_id
--						ORDER BY st.stop_sequence) -- delta-y
--				) > 0
--					THEN 4::INT2 -- North
--				ELSE 5::INT2 -- South
--			END
--			, CASE
--				WHEN (
--					LAST_VALUE(s.stop_lon::numeric) OVER (
--						PARTITION BY 
--							r.feed_id
--							, r.route_id
--							, r.trac_agency_id
--							, t.shape_id
--							, t.trip_id
--						ORDER BY st.stop_sequence ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
--					- FIRST_VALUE(s.stop_lon::numeric) OVER (
--						PARTITION BY 
--							r.feed_id
--							, r.route_id
--							, r.trac_agency_id
--							, t.shape_id
--							, t.trip_id
--						ORDER BY st.stop_sequence) -- delta-x
--				) > 0
--					THEN 6::INT2 -- East
--				ELSE 7::INT2 -- West
--			END 
--		] AS alt_direction_id
--		, monday
--		, tuesday
--		, wednesday
--		, thursday
--		, friday
--		, saturday
--		, sunday
--	FROM gtfs_test.v_most_current_routes_per_feed AS r -- this IS the TABLE we need FOR the route information
--	JOIN  _test.real_transitland_trips AS t
--		ON  r.feed_id = t.feed_id
--		AND t.route_id = r.route_id
--	JOIN _test.real_transitland_stop_times AS st
--		ON st.feed_id = r.feed_id
--		AND st.trip_id = t.trip_id
--	JOIN _test.real_transitland_stops AS s
--		ON s.feed_id = r.feed_id
--		AND s.stop_id = st.stop_id
--	LEFT JOIN _test.real_transitland_calendar AS c
--		ON t.feed_id = c.feed_id 
--		AND c.service_id = t.service_id
--);



--UPDATE gtfs_test.v_gtfs_trip_directions AS original
--	SET alt_direction_id = array_append(
--		CASE
--			WHEN direction_id = 1 
--				THEN
--					CASE 
--						WHEN ARRAY[4, 6]::SMALLINT[] <@ alt_direction_id
--							THEN alt_direction_id
--						WHEN ARRAY[5]::SMALLINT[] <@ alt_direction_id
--							THEN array_remove(alt_direction_id, 5)
--						WHEN ARRAY[7]::SMALLINT[] <@ alt_direction_id
--							THEN array_remove(alt_direction_id, 7)
--					END
--			WHEN direction_id = 0 
--				THEN 
--	            	CASE 
--						WHEN ARRAY[5, 7]::SMALLINT[] <@ alt_direction_id
--							THEN alt_direction_id
--						WHEN ARRAY[4]::SMALLINT[] <@ alt_direction_id
--							THEN array_remove(alt_direction_id, 4)
--						WHEN ARRAY[6]::SMALLINT[] <@ alt_direction_id
--							THEN array_remove(alt_direction_id, 6)
--					END
--		END,
--        CASE
--        	WHEN direction_id = 1 
--        		THEN 1
--        	WHEN direction_id = 0 
--        		THEN 2
--        END
--	)
--	WHERE original.trac_agency_id = 6;



--CREATE VIEW gtfs_test.v_gtfs_trip_stop_sequence AS (
--	SELECT DISTINCT 
--		t.feed_id
--		, t.route_id
--		, t.trac_agency_id
--		, t.trip_id
--		, t.shape_id
--		, t.direction_id
--		, t.alt_direction_id
--		, c.monday
--		, c.tuesday
--		, c.wednesday
--		, c.thursday
--		, c.friday
--		, c.saturday
--		, c.sunday
--		, st.arrival_time
--		, st.departure_time
--		, st.stop_id
--		, st.stop_sequence
--		, s.stop_location
--		, r.start_date
--		, r.end_date
--	FROM gtfs_test.v_gtfs_trip_directions AS t
--	JOIN _test.latest_gtfs_feeds_20240413 AS r
--		ON r.feed_id = t.feed_id 
--		AND r.route_id = t.route_id
--	JOIN _test.real_transitland_stop_times AS st
--		ON st.feed_id = t.feed_id
--		AND st.trip_id = t.trip_id
--	JOIN _test.real_transitland_stops AS s
--		ON s.feed_id = t.feed_id
--		AND s.stop_id = st.stop_id
--	LEFT JOIN _test.real_transitland_calendar AS c
--		ON t.feed_id = c.feed_id 
--		AND c.service_id = t.service_id
--	ORDER BY 
--		t.feed_id 
--		, t.trac_agency_id
--		, t.route_id 
--		, t.trip_id 
--		, t.shape_id 
--		, st.stop_sequence ASC
--);



--CREATE VIEW gtfs_test.v_gtfs_service_exceptions AS (
--	SELECT DISTINCT 
--		r.feed_id
--		, r.route_id
--		, r.trac_agency_id
--		, t.trip_id
--		, cd.date
--		, cd.exception_type
--	FROM gtfs_test.v_most_current_routes_per_feed AS r -- this IS the TABLE we need FOR the route information
--	JOIN  _test.real_transitland_trips AS t
--		ON  r.feed_id = t.feed_id
--		AND t.route_id = r.route_id
--	JOIN _test.real_transitland_calendar AS c
--		ON t.feed_id = c.feed_id 
--		AND c.service_id = t.service_id
--	JOIN _test.real_transitland_calendar_dates AS cd
--		ON c.feed_id = cd.feed_id 
--		AND c.service_id = cd.service_id
--	ORDER BY 
--		r.feed_id
--		, r.trac_agency_id
--		, r.route_id
--		, t.trip_id ASC
--); -- 512,439





CREATE VIEW gtfs_test.  AS (
	SELECT 
		txn_id, 
		corrected_direction_id AS direction_id
	FROM (
		SELECT  
			b1.*
			, b2.direction_id AS corrected_direction_id
			, ROW_NUMBER() OVER (
				PARTITION BY b1.txn_id
				ORDER BY abs_interval(b1.device_dtm_pacific - b2.device_dtm_pacific)
			) AS ranked
			, abs_interval(b1.device_dtm_pacific - b2.device_dtm_pacific) AS time_difference
		FROM _test.boarding_april23 AS b1
		JOIN _test.boarding_april23 AS b2
			ON  	b1.route_number = b2.route_number 
			AND b1.device_id = b2.device_id -- same tapping device
			AND b1.coach_number = b2.coach_number -- same vehicle
			AND b1.business_date = b2.business_date 
			AND b1.direction_id = 3 
			AND b2.direction_id != 3
	) ranked_data
	WHERE ranked = 1 AND time_difference <= '00:30:00'
);






-- PROCEDURE

CREATE OR REPLACE PROCEDURE gtfs_test.do_a_thing(_txn_id BIGINT)
LANGUAGE plpgsql AS $$
DECLARE 

	_orca_txn_rec RECORD;
--	_gtfs_rec RECORD;
--	_avl_rec RECORD;

	_gtfs_feed_id INT;
	_gtfs_route_id TEXT;
	_gtfs_trip_id TEXT;
	_trac_agency_id INT;
	_orca_coach_number TEXT;
	_avl_route_id TEXT;
	_avl_stop_id TEXT;
	_avl_direction_id INT;
	_avl_departure_dtm_pacific TIMESTAMP;
	_avl_check_code NUMERIC;
	_trac_check_code INT;
	_gtfs_check_code NUMERIC;
	_direction_final INT;
	_direction_note INT;
	_stop_final TEXT;
	_stop_note INT;
	_stop_location geometry(point, 32610);

	_trac_stop_location geometry(point,32610);
	_gtfs_stop_location geometry(point,32610);
	_trac_trip_id TEXT;
	_orca_txn_dow INT; 
	_orca_device_dtm_interval INTERVAL;


BEGIN
	
	
	
	
	
	SELECT  b.*
    INTO  _orca_txn_rec
   	FROM  orca.v_boardings b
    WHERE  b.txn_id = _txn_id;

	
	
	
		
	WITH orca_with_gtfs AS (
		SELECT   
			gtfs.feed_id AS feed_id
			, gtfs.route_id AS route_id -- we would use route_id, feed_id, and trac_agency_id TO JOIN btw orca AND gtfs later
			, gtfs.trac_agency_id AS agency_id
			, orca.coach_number AS coach_num
			, EXTRACT(DOW FROM orca.business_date) AS txn_dow
			, CASE 
				WHEN date_trunc('day', orca.device_dtm_pacific) > orca.business_date
					THEN TO_CHAR(orca.device_dtm_pacific, 'HH24:MI:SS')::INTERVAL + '24 hours'
				ELSE TO_CHAR(orca.device_dtm_pacific, 'HH24:MI:SS')::INTERVAL
			  END AS device_dtm_interval
			, ROW_NUMBER() OVER (
				PARTITION BY orca.txn_id
				ORDER BY gtfs.feed_id DESC ) AS latest_gtfs
		FROM orca.v_boardings AS orca-- orca
		LEFT JOIN trac.route_name_lookup AS lookup
			ON orca.route_number = lookup.route_number
				AND orca.service_agency_id = lookup.service_agency_id -- the lookup uses service_agency_id INSTEAD OF source
		JOIN trac.agencies AS trac -- lookup TABLE for agency_id BETWEEN orca AND gtfs
			ON trac.orca_agency_id = orca.source_agency_id
				OR trac.agency_id = lookup.trac_agency_id
		JOIN gtfs_test.v_most_current_routes_per_feed AS gtfs -- gtfs route valid START and END date
			ON (gtfs.route_short_name = orca.route_number
				OR COALESCE(gtfs.route_short_name, gtfs.route_long_name) ILIKE lookup.gtfs_route_name
				OR gtfs.route_id = orca.route_number ) -- New change 20240427: ALSO JOIN ON route_number
				AND orca.business_date BETWEEN gtfs.start_date AND gtfs.end_date
				AND gtfs.trac_agency_id = trac.agency_id
		WHERE (orca.device_location IS NOT NULL OR orca.stop_code IS NOT NULL) 
		AND orca.business_date BETWEEN '2023-04-01' AND '2023-04-30'
		AND orca.txn_id = _txn_id
	)
	SELECT
		feed_id, 
		route_id, 
		agency_id, 
		coach_num,
		txn_dow,
		device_dtm_interval
	INTO 
		_gtfs_feed_id, 
		_gtfs_route_id, 
		_trac_agency_id, 
		_orca_coach_number,
		_orca_txn_dow,
		_orca_device_dtm_interval
	FROM orca_with_gtfs
	WHERE latest_gtfs = 1;










	WITH ranked_avl_code AS (
		SELECT 
			avl.route_id AS route_id
			, avl.stop_id AS stop_id
			, avl.direction_id AS direction_id
			, avl.departure_dtm_pacific AS departure_dtm_pacific
			, CASE 
				WHEN orca.route_number = avl.route_id
					THEN 
						CASE
							WHEN COALESCE(cd.direction_id, orca.direction_id) = avl.direction_id
								THEN 1.1
							WHEN COALESCE(cd.direction_id, orca.direction_id) = 3 AND avl.direction_id IS NOT NULL 
								THEN 1.2 
							WHEN COALESCE(cd.direction_id, orca.direction_id) != 3 AND COALESCE(cd.direction_id, orca.direction_id) != avl.direction_id
								THEN 1.3
							WHEN avl.direction_id IS NULL
								THEN 1.4
						END
				WHEN orca.route_number != avl.route_id
					THEN 
						CASE
							WHEN avl.direction_id IS NOT NULL
								THEN 2.1 -- AVL direction exists
							ELSE 2.2 -- AVL direction does not exist
						END
				WHEN avl.route_id IS NULL
					THEN 3
			END AS avl_check_code
			, ROW_NUMBER () OVER (
				PARTITION BY orca.txn_id
				ORDER BY (
					CASE 
						WHEN orca.route_number = avl.route_id -- WHEN the route number matched
							THEN 
								CASE
									WHEN COALESCE(cd.direction_id, orca.direction_id) = avl.direction_id
										THEN 1.1 -- everything IS good
									WHEN COALESCE(cd.direction_id, orca.direction_id) = 3 
									AND avl.direction_id IS NOT NULL 
										THEN 1.2 -- UPDATE the orca direction WITH avl
									WHEN COALESCE(cd.direction_id, orca.direction_id) != 3 
									AND COALESCE(cd.direction_id, orca.direction_id) != avl.direction_id
										THEN 1.3 -- need GTFS
									WHEN avl.direction_id IS NULL
										THEN 1.4 -- need GTFS
								END
						WHEN orca.route_number != avl.route_id -- WHEN the route number does NOT match
							THEN 
								CASE
									WHEN avl.direction_id IS NOT NULL
										THEN 2.1 -- AVL direction exists
									ELSE 2.2 -- AVL direction does not exist
								END
						WHEN avl.route_id IS NULL -- WHERE there IS NO AVL match
							THEN 3
					END 
					, abs_interval(avl.departure_dtm_pacific - orca.device_dtm_pacific) -- orca_avl_time_interval 
				)
			) AS ranked_avl
		FROM orca.v_boardings AS orca
		LEFT JOIN agency.v_avl AS avl
			ON avl.agency_id = orca.source_agency_id -- agency
			AND avl.vehicle_id = orca.coach_number -- vehicle number
			AND avl.stop_id = orca.stop_code -- orca stop code
			AND abs_interval(avl.departure_dtm_pacific - orca.device_dtm_pacific) <= INTERVAL '5 minutes' -- WITHIN 5 minutes INTERVAL
		LEFT JOIN _test.txn_correct_april23 AS cd
			ON cd.txn_id = orca.txn_id
		WHERE orca.txn_id = _txn_id
	)
	SELECT 
		route_id
		, stop_id
		, direction_id
		, departure_dtm_pacific
		, avl_check_code
	FROM ranked_avl_code
	INTO 
		_avl_route_id
		, _avl_stop_id
		, _avl_direction_id
		, _avl_departure_dtm_pacific
		, _avl_check_code
	WHERE ranked_avl = 1;










	WITH info AS (
		SELECT    
			txn_id
			, business_date
			, txn_dow
			, device_mode_id
			, device_dtm_pacific
			, device_dtm_interval
			, source_agency_id
			, service_agency_id
			, coach_number
			, trip_ranked.direction_id
			, orca_updated_direction
			, stop_code
			, device_location
			, trip_ranked.feed_id
			, trip_ranked.route_id
			, trip_ranked.trac_agency_id
			, avl_route
			, avl_direction
			, avl_stop
		    , avl_departure_dtm
		    , avl_check_code
		    , trac_trip_id
		    , trac_direction_ids
			, gtfs.stop_id AS trac_stop_id
			, abs_interval(gtfs.departure_time - trip_ranked.device_dtm_interval) AS trac_time_difference
			, gtfs.stop_location AS trac_stop_location
			, ST_Distance(st_transform(trip_ranked.device_location, 32610), gtfs.stop_location) AS distance_trac_orca
			, CASE
				WHEN (gtfs.stop_id = stop_code) IS TRUE
					THEN 1 -- trac stop agree WITH orca stop
				WHEN (gtfs.stop_id = stop_code) IS FALSE
					THEN 2 -- trac stop agree WITH orca stop
				WHEN stop_code IS NULL AND gtfs.stop_id IS NOT NULL
					THEN 3 -- orca stop_code NOT EXISTS but we still have trac matched
				WHEN gtfs.stop_id IS NULL
					THEN 4 -- NO trac matched
			END AS trac_check_code
			, ROW_NUMBER() OVER (
				PARTITION BY trip_ranked.txn_id
				-- choosing the shortest wait time trip for each shape id
				ORDER BY
					CASE
						WHEN (gtfs.stop_id = stop_code) IS TRUE
							THEN 1 -- trac stop agree WITH orca stop
						WHEN (gtfs.stop_id = stop_code) IS FALSE
							THEN 2 -- trac stop agree WITH orca stop
						WHEN stop_code IS NULL AND gtfs.stop_id IS NOT NULL
							THEN 3 -- orca stop_code NOT EXISTS but we still have trac matched
						WHEN gtfs.stop_id IS NULL
							THEN 4 -- NO trac matched
					END ASC 
				, abs_interval(gtfs.departure_time - trip_ranked.device_dtm_interval) ASC
			) AS trac_rank
		FROM (
			SELECT
			      orca.*
			    , gtfs.trip_id AS trac_trip_id
			    , gtfs.alt_direction_id AS trac_direction_ids
			    , CASE
						WHEN ARRAY[orca.stop_code] <@ gtfs.stops_arr -- prioritizing matching stop id 
							 THEN 1
						ELSE 2
				  END stop_exist
			    , ROW_NUMBER() OVER (
						PARTITION BY orca.txn_id
						-- choosing the shortest wait time trip for each shape id
						ORDER BY
							CASE
								WHEN ARRAY[orca.stop_code] <@ gtfs.stops_arr -- prioritizing matching stop id 
									 THEN 1
								ELSE 2
							END ASC
							, CASE
								WHEN ARRAY[orca.stop_code] <@ gtfs.stops_arr -- prioritizing matching stop id 
									THEN 
										abs_interval(
											( -- Calculate estimated arrival time for the stop based on sequence position and trip duration
												-- estimate the time of arrival for a stop code based on the sequence of stops and the start and end time of the trip
												(gtfs.first_stop_time - INTERVAL '3 minutes' + gtfs.last_stop_time + INTERVAL '15 minutes')
												/array_length(gtfs.stops_arr, 1) -- Divide this duration by the number of stops to get the average time between stops
											)  
											* array_position(gtfs.stops_arr, orca.stop_code) --Multiply the average time between stops by the position of the stop code within the sequence to estimate the arrival time for that stop.
										    - _orca_device_dtm_interval) -- Subtract the estimated arrival time for the stop from the ORCA device timestamp to get the estimated time difference.
								ELSE
									abs_interval( ((gtfs.first_stop_time - INTERVAL '3 minutes' + gtfs.last_stop_time + INTERVAL '15 minutes')/2) - _orca_device_dtm_interval)
							END
					  ) AS ranked
			FROM _test.boarding_avl_april23_filtered_20240413 AS orca
			LEFT JOIN _test.gtfs_route_service_exception_20240413 AS exc -- EXCEPTION service dates for the route/shape
				ON exc.feed_id = orca.feed_id
				   AND exc.trac_agency_id = orca.trac_agency_id
				   AND exc.route_id = orca.route_id
				   AND orca.business_date = exc.date
			LEFT JOIN _test.gtfs_route_trip_direction_20240413 AS gtfs
	    		ON 	orca.feed_id = gtfs.feed_id
	    			AND orca.route_id = gtfs.route_id
	    			AND orca.trac_agency_id = gtfs.trac_agency_id
	    			AND _orca_device_dtm_interval BETWEEN
	    				gtfs.first_stop_time - INTERVAL '3 minutes' AND gtfs.last_stop_time + INTERVAL '15 minutes'-- txn must be WITHIN the FIRST AND LAST stop time
					AND ( -- JOIN ON direction
						(ARRAY[COALESCE(orca.orca_updated_direction, orca.direction_id)] <@ gtfs.alt_direction_id 
							AND orca.avl_check_code != 1.2)
						OR
						(ARRAY[orca.avl_direction] <@ gtfs.alt_direction_id
							AND orca.avl_check_code = 1.2)
					  )
		            AND
					CASE
			            WHEN orca.txn_dow = 0 -- SUNDAY
			            	THEN
			            		   (gtfs.sunday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.sunday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.sunday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.sunday IS NULL)
			            WHEN orca.txn_dow = 1 -- MONDAY
			            	THEN
			            		   (gtfs.monday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.monday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.monday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.monday IS NULL)
			            WHEN orca.txn_dow = 2 -- TUESDAY
			            	THEN
			            		   (gtfs.tuesday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.tuesday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.tuesday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.tuesday IS NULL)
			            WHEN orca.txn_dow = 3 -- WEDNESDAY
			            	THEN
			            		   (gtfs.wednesday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.wednesday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.wednesday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.wednesday IS NULL)
			            WHEN orca.txn_dow = 4 -- THURSDAY
			            	THEN
			            		   (gtfs.thursday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.thursday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.thursday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.thursday IS NULL)
			            WHEN orca.txn_dow = 5 -- FRIDAY
			            	THEN
			            		   (gtfs.friday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.friday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.friday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
			            		OR (gtfs.friday IS NULL)
			            WHEN orca.txn_dow = 6 -- SATURDAY
			            	THEN
			            		   (gtfs.saturday = 1 AND exc.exception_type IS NULL)
			            		OR (gtfs.saturday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
			            		OR (gtfs.saturday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)  
			            		OR (gtfs.saturday IS NULL)
				  END
			) AS trip_ranked
		LEFT JOIN _test.gtfs_route_trip_stop_sequence_20240413 AS gtfs
		ON 	trip_ranked.feed_id = gtfs.feed_id
			AND trip_ranked.route_id = gtfs.route_id
			AND trip_ranked.trac_agency_id = gtfs.trac_agency_id
			AND trip_ranked.trac_trip_id = gtfs.trip_id
			AND CASE -- JOIN ON time OF txn time
		   		WHEN trip_ranked.device_mode_id = 10 OR trip_ranked.device_mode_id = 11 -- lightrail OR sounder
		   			THEN
		   				gtfs.departure_time BETWEEN
		   					trip_ranked.device_dtm_interval + INTERVAL '1 minutes' -- AFTER tap, allow upto 1 min TO GET TO the lightrail/sounder BY stairs/elevators
		   					AND trip_ranked.device_dtm_interval + INTERVAL '45 minutes' -- AFTER tap, might need TO wait upto 30 mins BEFORE the lightrail/sounder depart
		   		ELSE -- bus
		   			gtfs.departure_time BETWEEN
		   				trip_ranked.device_dtm_interval - INTERVAL '2 minutes' -- bus arriving 2 minutes early from the schedule
		   				AND trip_ranked.device_dtm_interval + INTERVAL '45 minutes' -- bus arriving 30 minutes late from the schedule
		   	    END
		   	AND CASE 
		   		WHEN stop_exist = 1 
		   			THEN
		   				gtfs.stop_id =  trip_ranked.stop_code
		   		ELSE TRUE 
		   	    END
		WHERE ((ranked = 1 AND stop_exist = 2)
			  OR (ranked <= 3 AND stop_exist = 1))
		AND txn_id = _txn_id
	)
	SELECT
		trac_check_code
		, trac_stop_location
		, trac_trip_id
	INTO 
		_trac_check_code
		, _trac_stop_location
		, _trac_trip_id
	FROM info
	WHERE trac_rank = 1;

















	WITH gtfs_ranked AS (
			SELECT DISTINCT 
				  orca.*
				, gtfs.trip_id AS gtfs_trip_id
				, gtfs.stop_location AS gtfs_stop_location
				, abs_interval(gtfs.departure_time - _orca_device_dtm_interval) AS gtfs_time_difference
				, ST_Distance(st_transform(orca.device_location, 32610), st_transform(gtfs.stop_location, 32610)) AS distance_gtfs_orca
				, gtfs.alt_direction_id AS gtfs_alt_direction_id
				, CASE 
					WHEN (ARRAY[COALESCE(orca.orca_updated_direction, orca.direction_id)] <@ gtfs.alt_direction_id)
						THEN 1.1 -- WHEN orca matched
					WHEN (ARRAY[orca.avl_direction] <@ gtfs.alt_direction_id)
						THEN 1.2 -- WHEN orca does not matched but avl matched
					WHEN gtfs.alt_direction_id IS NOT NULL
						THEN 1.3 -- the stop serve the route but none of direction matched
					WHEN gtfs.alt_direction_id IS NULL
						THEN 2  -- WHEN this orca stop does NOT serve this route AT all
				  END AS gtfs_check_code
				, ROW_NUMBER() OVER (
					PARTITION BY orca.txn_id
					ORDER BY
						CASE 
							WHEN (ARRAY[COALESCE(orca.orca_updated_direction, orca.direction_id)] <@ gtfs.alt_direction_id)
								  OR (ARRAY[orca.avl_direction] <@ gtfs.alt_direction_id)
								THEN 1 -- WHEN orca/avl direction matched
							WHEN gtfs.alt_direction_id IS NOT NULL
								THEN 2 -- the stop serve the route but none of direction matched
							WHEN gtfs.alt_direction_id IS NULL
								THEN 3 -- WHEN this orca stop does NOT serve this route AT all
						END ASC -- FIRST, ORDER BY the direction
						, abs_interval(gtfs.departure_time - _orca_device_dtm_interval) ASC -- THEN BY the time difference
				  ) AS gtfs_rank
			FROM _test.boarding_avl_trac_april23_20240413 orca
			LEFT JOIN _test.gtfs_route_service_exception_20240413 exc -- EXCEPTION service dates for the route/shape
				ON exc.feed_id = orca.feed_id
				   AND exc.trac_agency_id = orca.trac_agency_id
				   AND exc.route_id = orca.route_id
				   AND orca.business_date = exc.date
			LEFT JOIN _test.gtfs_route_trip_stop_sequence_20240413 gtfs
		    		ON 	orca.feed_id = gtfs.feed_id
		    			AND orca.route_id = gtfs.route_id
		    			AND orca.trac_agency_id = gtfs.trac_agency_id
		    			AND orca.stop_code = gtfs.stop_id -- JOIN ON stop id
		    			AND CASE -- JOIN ON time OF txn time
					   		WHEN orca.device_mode_id = 10 OR orca.device_mode_id = 11 -- lightrail OR sounder
					   			THEN
					   				gtfs.departure_time BETWEEN
					   					_orca_device_dtm_interval - INTERVAL '1 minutes' -- AFTER tap, allow upto 1 min TO GET TO the lightrail/sounder BY stairs/elevators
					   					AND _orca_device_dtm_interval + INTERVAL '45 minutes' -- AFTER tap, might need TO wait upto 30 mins BEFORE the lightrail/sounder depart
					   		ELSE -- bus
					   			gtfs.departure_time BETWEEN
					   				_orca_device_dtm_interval - INTERVAL '2 minutes' -- bus arriving 2 minutes early from the schedule
					   				AND _orca_device_dtm_interval + INTERVAL '45 minutes' -- bus arriving 30 minutes late from the schedule
					   	    END
						AND -- JOIN ON service day
						   CASE
					            WHEN orca.txn_dow = 0 -- SUNDAY
					            	THEN
					            		   (gtfs.sunday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.sunday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.sunday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.sunday IS NULL)
					            WHEN orca.txn_dow = 1 -- MONDAY
					            	THEN
					            		   (gtfs.monday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.monday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.monday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.monday IS NULL)
					            WHEN orca.txn_dow = 2 -- TUESDAY
					            	THEN
					            		   (gtfs.tuesday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.tuesday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.tuesday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.tuesday IS NULL)
					            WHEN orca.txn_dow = 3 -- WEDNESDAY
					            	THEN
					            		   (gtfs.wednesday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.wednesday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.wednesday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.wednesday IS NULL)
					            WHEN orca.txn_dow = 4 -- THURSDAY
					            	THEN
					            		   (gtfs.thursday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.thursday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.thursday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.thursday IS NULL)
					            WHEN orca.txn_dow = 5 -- FRIDAY
					            	THEN
					            		   (gtfs.friday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.friday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.friday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)
					            		OR (gtfs.friday IS NULL)
					            WHEN orca.txn_dow = 6 -- SATURDAY
					            	THEN
					            		   (gtfs.saturday = 1 AND exc.exception_type IS NULL)
					            		OR (gtfs.saturday = 1 AND exc.trip_id = gtfs.trip_id AND exc.exception_type != 2)
					            		OR (gtfs.saturday = 0 AND exc.trip_id = gtfs.trip_id AND exc.exception_type = 1)  
					            		OR (gtfs.saturday IS NULL)
						  END
	)
	SELECT
		gtfs_check_code
		, gtfs_stop_location
		, gtfs_trip_id
	INTO 
		_gtfs_check_code
		, _gtfs_stop_location
		, _gtfs_trip_id
	FROM gtfs_ranked
	WHERE txn_id = _txn_id
	AND gtfs_rank = 1;




















































	INSERT INTO gtfs_test.test_final_table VALUES (
		_txn_id, 
		_orca_coach_number, 
		_gtfs_feed_id, 
		_gtfs_route_id,
		_gtfs_trip_id,
		_trac_agency_id, 
		_avl_route_id, 
		_avl_stop_id, 
		_avl_direction_id,
		_avl_departure_dtm_pacific, 
		_avl_check_code, 
		_trac_check_code, 
		_gtfs_check_code, 
		NULL, 
		NULL, 
		NULL, 
		NULL, 
		NULL);
	
	
	
END;
$$;





-- SETUP:
	
		-- 1.) create a view that gets the latest feed with unique start and end dates for all the routes for each agency from gtfs data 
			-- USING:
				-- feeds, routes, trips, and calendar gtfs tables

		-- 2.) using view from step 1, append gtfs feed_id, route_id, and trac_agency_id to the orca transaction
			-- USING: 
				-- lookup tables to join on similar values
			-- CONDITIONS: 
				-- orca device location or stop code not null

		-- 3.) for all trips in a route for gtfs data, identify cardinal direction to use over orca's direction_id, append service day data from gtfs calendar
			-- USING:
				-- view from step 1, gtfs trips, stops, stop_times, and calendar

		-- 4.) update step 3 with avl direction id, adding either 1 (inbound) or 2 (outbound) to cardinal direction array
			-- CONDITION:
				-- agency_id = 6, pierce_transit
			-- CREATE:
				-- index 

		-- 5.) bring all the variables together for every stop
			-- USING:
				-- step 4: route_id, t.trac_agency_id, t.trip_id, t.shape_id, t.direction_id, t.alt_direction_id
				-- step 1: start and end dates
				-- gtfs stops, stop_times, and calendar
			-- CEATE: 
				-- indexes

		-- 6.) bring together variables for service dates and exception types for 
			-- USING: 
				-- view from step 1, trips, calendar, and calendar dates

		-- 7.) create function

		-- 8.) if transaction has direction_id = 3 (unknown), then assume the direction using transaction with same route_number, device_id, coach_number
			-- and business date that are within 30 min from each other

		-- 9.) AVL data checks
	
		-- get all the stops for each unique combination of route_id, direction (in or outbound) and alt_direc
	
		-- for when direction id = 3 meaning unknown, creates a view of these taps with approximated direction id defined by comparing to taps of the 
		-- same parameters
	
		-- join orca and avl on agency, vehicle_id, orca_stop_id, within 5 minutes ALSO, correct the cases where direction_id = 3
	
		-- chooses the best join based on ranking / quality and if their are 2 or more of the same quality for the same tap, then we pick the one with 
		-- the lowest time interval
		-- now, only select the first case
	
	-- ADDITIONS:
	
		-- append feed id and route id and trac agency id to orca data
	
		-- join ORCA with GTFS based on route name and direction
			-- also, for the avl_check_code = 1.2, we will use the avl_direction instead of orca's
			-- we join orca with gtfs based on departure time and device dtm pacific when the business date is in service, checking for exception dates
		-- we define the trac_check_code as:
			-- (1) when orca's stop_code equals to trac's stop_id
			-- (2) when orca's stop_code NOT equals to trac's stop_id
			-- (3) when orca's stop_code is NULL
			-- (4) when trac's stop_id is NULL --> no route/direction matched
	
		-- join gtfs with orca route_name and stop_code
		-- gtfs_check_code: check if the stops serve the route in this specified orca_direction
			-- Case 1: Where this stop_code do serve this route:
				-- (1.1) if orca direction is contained within gtfs_combined_direction
				-- (1.2) if orca direction NOT contained within gtfs_combined_direction
				-- 			BUT AVL is 
				-- (1.3) GTFS does not agree to both orca AND avl OR avl is null 
			-- Case 2: Where this stop_code do NOT serve this route -- No GTFS matched:
				-- (2) 
	
	-- boarding final table
	
	
	-- next borading
	
		-- if light rail OR sounder:
			-- if there is an alight_txn_id in v_linked_transactions:
				-- ?verify that orca.transactions stop_id is along gtfs route?
			    -- use orca.transactions stop_id and device_dtm_pacific for alighting info
			    -- also get disance from stop to next boarding stop
		 	-- if no alight_txn_id: this becomes like the bus tapoff estimate
		    	-- use gtfs data to get next light rail stop within 1/3 mile of next boarding
		-- if bus and route not 44444 or 22222:
			-- use next boarding stop location to find any stops along current route within 1/3 mile
		-- if bus and route 44444 or 22222:
			-- use process written on paper







-- CREATE TABLE gtfs_test.test_final_table(txn_id INT, coach_number TEXT, feed_id INT, gtfs_route_id TEXT, gtfs_trip_id TEXT, trac_agency_id INT, avl_route TEXT, avl_stop TEXT, avl_direction INT, avl_departure_dtm TIMESTAMP, avl_check_code NUMERIC, trac_check_code INT, gtfs_check_code NUMERIC, direction_final INT, direction_note INT, stop_final TEXT, stop_note INT, stop_location geometry)

-- DROP TABLE gtfs_test.test_final_table



-- CALL gtfs_test.do_a_thing(211614512);
-- CALL gtfs_test.do_a_thing(199405180);
-- CALL gtfs_test.do_a_thing(211358950);
-- CALL gtfs_test.do_a_thing(206767892);
-- CALL gtfs_test.do_a_thing(197132704);
-- CALL gtfs_test.do_a_thing(202856738);
-- CALL gtfs_test.do_a_thing(208686418);
-- CALL gtfs_test.do_a_thing(209928122);
-- CALL gtfs_test.do_a_thing(207401056);
-- CALL gtfs_test.do_a_thing(213963884);


-- SELECT * FROM gtfs_test.test_final_table;

-- TRUNCATE gtfs_test.test_final_table


-- SELECT * FROM _test.boarding_action_final_april23_20240413 ORDER BY RANDOM()LIMIT 10
